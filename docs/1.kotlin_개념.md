# Kotlin 만의 개념 

### 1. Companion Object
   - Companion Object는 클래스 내부에 정의된 객체로, 해당 클래스의 정적 멤버를 정의할 때 사용됩니다.
     - Java 의 static 을 대체하기 위한 기능 다만 내부적으로 완전히 동일하지 않음
     - 정적 함수, 상수 정의 에서 사용한다. 
     - Companion Object는 Singleton 객체 이다.
       - 오버라이딩은 불가하지만, 상속/인터페이스 구현은 가능하다.
     - 클래스 당 1개만 정의할 수 있다.
   - Java의 static 멤버와 유사하지만, Companion Object는 클래스의 인스턴스 없이도 접근할 수 있다.
   - Java 에서 Companion Object 를 호출하려면 MyClass.Companion.myFunction() 형태로 호출해야 한다.
     - 다만 @JvmStatic 어노테이션을 사용하면, MyClass.myFunction() 형태로 호출할 수 있다.
- 예시:
```kotlin
class MyClass {
  // Class 내부 선언(정의) - 싱글턴 
  companion object {
      fun myFunction() {
          println("Hello from Companion Object")
      }
  }
}

MyClass.myFunction() // 호출 방법

// 인터페이스 구현, 정적 팩토리 메서드 역할 가능(Static Factory Method)
interface Factory<T> {
    fun create(): T
}

class User {
    companion object : Factory<User> {
        override fun create() = User()
    }
}
```
```java
 public class MyClass {
     public static void myFunction() {
         System.out.println("Hello from Companion Object");
     }
 }
 
// 호출 방법 - 클래스 로딩시 메모리에 적재
 MyClass.myFunction();   
```

- object 와의 차이
  - 클래스 없이 단독으로 정의되는것 -> object
    - static 대체가 아님 -> 다만 싱글턴 객체로 사용 가능
  - object 자체가 Singleton 객체이게, Primary Constructor, Secondary Constructor 를 가질 수 없다.
- 클래스 내부 선언, 클래스와 연결된 정적 객체(Java Static 대체) -> Companion Object
<br><br>
- 사용처
  - object
    - 공통 유틸 함수/상수 모음: JsonUtils.parseJson()
    - 싱글톤 서비스 정의: object ServiceImpl
    - 인터페이스 구현 : object SomeInterface {}
  - companion object
    - 클래스 정적 메서드(static method)
      - User.createUser() 처럼 클래스의 인스턴스를 반환하는 정적 메서드 `fun createUser(): User = User()`

---
### 2. Open 키워드
- Kotlin 에서는 기본적으로 클래스와 메서드가 final 로 선언되어 상속이 불가능.
- Open 키워드를 사용하여 클래스나 메서드를 상속 가능하도록 선언할 수 있다.
- 또한 오버라이드 가능한 메서드도 Open 키워드를 사용하여 선언할 수 있다.
  - 기본적으로는 final 이기 때문에, 오버라이드가 불가능하다.

---

### 3. Data Class
- 데이터 클래스를 사용하면, 클래스의 주 생성자에 정의된 프로퍼티를 자동으로 생성해준다.
- equals(), hashCode(), toString() 메서드도 자동으로 생성된다.
- copy() 도 자동으로 생성되어, 불변객체인 데이터 클래스를 복사하여 값을 수정하는데 유용하다

---
### @JvmField || const val 
- static final 로 선언되는 상수나 필드를 정의할 때 사용한다.
- companion object 내부에 정의 한다.
- 둘다 접근 방법은 똑같음. 다만 사용 용도가 다르다.
- 
  - const val
    - 컴파일 타임 상수
    - String, Int, Long 과 같은 기본타입만 가능
    - public static final 상수 이다.
    - 어노테이션 붙이기 불가, 리플렉션 불가
    - "상수" 일 경우 사용함.
  - @JvmField
    - public static final 필드로 선언
    - 필드 접근 가능 
    - 모든 타입 가능(객체, 함수 등)
    - 런타임 상수, 설정값, 환경변수 등에서 사용 또한 어노테이션의 대상임
    - List, Map 등 컬렉션이나 객체일 때 사용
